K:=AlgebraicClosure(Rationals());
K4:=CartesianPower(K,4);
R<x>:=PolynomialRing(K);
i:=Roots(x^2+1)[1,1];
w5:=Roots(x^5-1)[2,1];

A:=Matrix(K,2,[1,0,0,-1]);
B:=Matrix(K,2,[0,1,1,0]);
C:=Matrix(K,2,[i,-i,1,1]);
D:=Matrix(K,2,[1,-i,i,-1]);
E:=Matrix(K,2,[1,1-w5-w5^-1,1,-1]);
F:=Matrix(K,2,[w5,0,0,1]);
I:=Matrix(K,2,[1,0,0,1]);


//The following function takes two ordered sets of n+2 points of P^n in general linear position, and returns the unique matrix in PGL_{n+1} which takes the first set to the second one.


AutPn:=function(points,images,n)
	points:=[<t:t in P>:P in points];
	images:=[<t:t in Q>:Q in images];
	A1:=AffineSpace(K,n+1);
	DefPols1:=[&+([A1.j*points[j+1][i]:j in [1..n+1]] cat [-points[1][i]]):i in [1..n+1]];
	X1:=Scheme(A1,DefPols1);
    sols1:=RationalPoints(X1);
	eltsM1:=[];
	for i in [1..n+1] do
		P:=[points[i+1,j]:j in [1..n+1]];
		eltsM1:=eltsM1 cat ElementToSequence(sols1[1][i]*Vector(K,n+1,P));
	end for;
    M1:=Transpose(Matrix(K,n+1,eltsM1));
	DefPols2:=[&+([A1.j*images[j+1][i]:j in [1..n+1]] cat [-images[1][i]]):i in [1..n+1]];
	X2:=Scheme(A1,DefPols2);
	sols2:=RationalPoints(X2);
	eltsM2:=[];
	for i in [1..n+1] do
		Q:=[images[i+1,j]:j in [1..n+1]];
		eltsM2:=eltsM2 cat ElementToSequence(sols2[1][i]*Vector(K,n+1,Q));
	end for;
	M2:=Transpose(Matrix(K,n+1,eltsM2));
	M:=M2*M1^-1;
	return M;
end function;

//The following function takes a triple (M1,M2,s) \in PGL_2^2\rtimes C_2=Aut(P1xP1), and returns the matrix of PGL_4 whose restriction on the quartic xt=yz gives the corresponding automorphism after Segre embedding.

AutQuadSurf:=function(M1,M2,s)
	M1:=Matrix(K,2,ElementToSequence(M1));
	M2:=Matrix(K,2,ElementToSequence(M2));
	if s eq 0 then
		g:=map<K4->K4|x:-><(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[1],(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[2],(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[3],(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[4]>>;
	else
		g:=map<K4->K4|x:-><(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[1],(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[2],(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[3],(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[4]>>;
	end if;
	Phi:=map<K4->K4|x:-><x[1]*x[3],x[1]*x[4],x[2]*x[3],x[2]*x[4]>>;
	PhiInv:=map<K4->K4|x:-><x[1]+x[2],x[3]+x[4],x[1]+x[3],x[2]+x[4]>>;
	g1:=map<K4->K4|x:->Phi(g(PhiInv(x)))>;
	
	points:=[<2,8,1,4>,<1,1,0,0>,<1,0,1,0>,<0,1,0,1>,<0,0,2,1>];
	images:=[g1(points[1]),g1(points[2]),g1(points[3]),g1(points[4]),g1(points[5])];
	return AutPn(points,images,3);	
end function;

//The following function takes a list of invertible matrices, and returns the subgroup of PGL they generate.

SGPGL:=function(matrices)
	dimension:=Nrows(matrices[1]);
   	matrices:=[M/Roots(x^dimension-R!Determinant(M))[1,1]:M in matrices];
	G:=sub<GL(dimension,K)|[GL(dimension,K)|M: M in matrices]>;
	D:=[M: M in Center(G) | IsScalar(M)];
	GP:=quo<G|D>;
	return(GP);
end function;

SGAutP1P1:=function(triples)
	matrices:=[AutQuadSurf(t[1],t[2],t[3]):t in triples];
	return SGPGL(matrices);
end function;

//In what follows, IdentifyGroup is the built-in function which returns the GAP ID of a finite group, if it exists.

//Checking the generators given in Notation 3.6, for A4, S4, and A5:

print "GAP ID of the subgroup of PGL_2 generated by A,B and C:", IdentifyGroup(SGPGL([A,B,C]));
print "GAP ID of the subgroup of PGL_2 generated by A,B,C and D:", IdentifyGroup(SGPGL([A,B,C,D]));
print "GAP ID of the subgroup of PGL_2 generated by E and F:", IdentifyGroup(SGPGL([E,F])),"\n";

//Checking the GAP IDs in Proposition 5.10:

print "GAP IDs of the subgroups of Aut(P^1xP^1) given in Proposition 5.12:\n";

IdentifyGroup(SGAutP1P1([<A,A,0>,<B,B,0>,<C,C,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,A,0>,<B,B,0>,<C,C,0>,<D,D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<I,C,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<I,C^2,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,C*D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,C^2*D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,D,1>]));



//Checking the GAP IDs in Proposition 5.12:

print "\n GAP IDs of the subgroups of Aut(P^1xP^1) given in Proposition 5.12:\n";

IdentifyGroup(SGAutP1P1([<A,A,0>,<B,B,0>,<C,C,0>,<D,D,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,D,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,D,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,D,0>,<I,D,1>]));

//The last group is of order 1152, hence does not have a GAP ID. But it is easy to show that its isomorphism class is S4 \wr C_2.

G:=SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,I,0>,<I,I,1>]);
print "Last group. Order: ",Order(G)," description: ",GroupName(G);