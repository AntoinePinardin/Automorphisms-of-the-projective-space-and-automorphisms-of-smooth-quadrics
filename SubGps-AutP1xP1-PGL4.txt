K:=AlgebraicClosure(Rationals());
K4:=CartesianPower(K,4);
R<x>:=PolynomialRing(K);
i:=Roots(x^2+1)[1,1];
w5:=Roots(x^5-1)[2,1];

A:=Matrix(K,2,[1,0,0,-1]);
B:=Matrix(K,2,[0,1,1,0]);
C:=Matrix(K,2,[i,-i,1,1]);
D:=Matrix(K,2,[1,-i,i,-1]);
E:=Matrix(K,2,[1,1-w5-w5^-1,1,-1]);
F:=Matrix(K,2,[w5,0,0,1]);
I:=Matrix(K,2,[1,0,0,1]);


//The following function takes two ordered sets of 4 points of P3 in general position, and returns the unique matrix in PGL_4 which takes the first set to the second one.


AutP3:=function(points,images)
	points:=[<t:t in points[1]>,<t:t in points[2]>,<t:t in points[3]>,<t:t in points[4]>,<t:t in points[5]>];
    images:=[<t:t in images[1]>,<t:t in images[2]>,<t:t in images[3]>,<t:t in images[4]>,<t:t in images[5]>];
	A1<a,b,c,d>:=AffineSpace(K,4);
    X1:=Scheme(A1,[a*points[2][1]+b*points[3][1]+c*points[4][1]+d*points[5][1]-points[1][1],a*points[2][2]+b*points[3][2]+c*points[4][2]+d*points[5][2]-points[1][2],a*points[2][3]+b*points[3][3]+c*points[4][3]+d*points[5][3]-points[1][3],a*points[2][4]+b*points[3][4]+c*points[4][4]+d*points[5][4]-points[1][4]]);
    sols1:=RationalPoints(X1);
	eltsM1:=[];
	for i in [1..4] do
		eltsM1:=eltsM1 cat ElementToSequence(sols1[1][i]*Vector(K,4,[points[i+1][1],points[i+1][2],points[i+1][3],points[i+1][4]]));
	end for;
    M1:=Transpose(Matrix(K,4,eltsM1));
	
	X2:=Scheme(A1,[a*images[2][1]+b*images[3][1]+c*images[4][1]+d*images[5][1]-images[1][1],a*images[2][2]+b*images[3][2]+c*images[4][2]+d*images[5][2]-images[1][2],a*images[2][3]+b*images[3][3]+c*images[4][3]+d*images[5][3]-images[1][3],a*images[2][4]+b*images[3][4]+c*images[4][4]+d*images[5][4]-images[1][4]]);
	sols2:=RationalPoints(X2);
	eltsM2:=[];
	for i in [1..4] do
		eltsM2:=eltsM2 cat ElementToSequence(sols2[1][i]*Vector(K,4,[images[i+1][1],images[i+1][2],images[i+1][3],images[i+1][4]]));
	end for;
	M2:=Transpose(Matrix(K,4,eltsM2));
	
	M:=M2*M1^-1;
	return M;
end function;

//The following function takes a triple (M1,M2,s) \in PGL_2^2\rtimes C_2=Aut(P1xP1), and returns the matrix of PGL_4 whose restriction on the quartic xt=yz gives the corresponding automorphism after Segre embedding.

AutQuadSurf:=function(M1,M2,s)
	M1:=Matrix(K,2,ElementToSequence(M1));
	M2:=Matrix(K,2,ElementToSequence(M2));
	if s eq 0 then
		g:=map<K4->K4|x:-><(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[1],(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[2],(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[3],(ElementToSequence(M1*Matrix(K,2,1,[x[1],x[2]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[3],x[4]])))[4]>>;
	else
		g:=map<K4->K4|x:-><(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[1],(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[2],(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[3],(ElementToSequence(M1*Matrix(K,2,1,[x[3],x[4]])) cat ElementToSequence(M2*Matrix(K,2,1,[x[1],x[2]])))[4]>>;
	end if;
	Phi:=map<K4->K4|x:-><x[1]*x[3],x[1]*x[4],x[2]*x[3],x[2]*x[4]>>;
	PhiInv:=map<K4->K4|x:-><x[1]+x[2],x[3]+x[4],x[1]+x[3],x[2]+x[4]>>;
	g1:=map<K4->K4|x:->Phi(g(PhiInv(x)))>;
	
	points:=[<2,8,1,4>,<1,1,0,0>,<1,0,1,0>,<0,1,0,1>,<0,0,2,1>];
	images:=[g1(points[1]),g1(points[2]),g1(points[3]),g1(points[4]),g1(points[5])];
	return AutP3(points,images);	
end function;

//The following function takes a list of invertible matrices and their size, and returns the subgroup of PGL they generate.

SGPGL:=function(matrices,dimension)
    gens:=[];
    for M in matrices do
        gens:=Append(gens,M/Roots(x^dimension-R!Determinant(M))[1,1]);
    end for;
    G:=sub<GL(dimension,K)|[GL(dimension,K)|M: M in gens]>;
    D:=[M: M in Center(G) | IsScalar(M)];
    GP:=quo<G|D>;
    return(GP);
end function;

SGAutP1P1:=function(triples)
	matrices:=[AutQuadSurf(t[1],t[2],t[3]):t in triples];
	return SGPGL(matrices,4);
end function;

//In what follows, IdentifyGroup is the built-in function which returns the GAP ID of a finite group, if it exists.

//Checking the generators given in Notation 3.6, for A4, S4, and A5:

print "GAP ID of the subgroup of PGL_2 generated by A,B and C:", IdentifyGroup(SGPGL([A,B,C],2));
print "GAP ID of the subgroup of PGL_2 generated by A,B,C and D:", IdentifyGroup(SGPGL([A,B,C,D],2));
print "GAP ID of the subgroup of PGL_2 generated by E and F:", IdentifyGroup(SGPGL([E,F],2)),"\n";

//Checking the GAP IDs in Proposition 5.10:

print "GAP IDs of the subgroups of Aut(P^1xP^1) given in Proposition 5.12:\n";

IdentifyGroup(SGAutP1P1([<A,A,0>,<B,B,0>,<C,C,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,A,0>,<B,B,0>,<C,C,0>,<D,D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<I,C,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<I,C^2,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,C*D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,C^2*D,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,D,1>]));



//Checking the GAP IDs in Proposition 5.12:

print "\n GAP IDs of the subgroups of Aut(P^1xP^1) given in Proposition 5.12:\n";

IdentifyGroup(SGAutP1P1([<A,A,0>,<B,B,0>,<C,C,0>,<D,D,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,C,0>,<D,D,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,D,0>,<I,I,1>]));
IdentifyGroup(SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,D,0>,<I,D,1>]));

//The last group is of order 1152, hence does not have a GAP ID. But it is easy to show that its isomorphism class is S4 \wr C_2.

G:=SGAutP1P1([<A,I,0>,<B,I,0>,<C,I,0>,<D,I,0>,<I,I,1>]);
print "Last group. Order: ",Order(G)," description: ",GroupName(G);